<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chiptune Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="/static/styles.css">
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>
    <style>
        .navbar {
            min-height: 70px;
        }
        .navbar .container-fluid {
            display: flex;
            align-items: center;
            height: 100%;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top">
        <div class="container-fluid">
            <a class="nav-link" href="/history">История генераций</a>
            <a class="nav-link" href="/auth">Авторизация</a>
            <button id="navbarLogoutButton" class="btn btn-danger ms-auto" style="display: none;">Выйти</button>
        </div>
    </nav>
    <h1 style="margin-top: 50px">Chiptune Generator</h1>
    <div class="button-container">
        <button class="btn btn-primary" onclick="generateTrack()">Сгенерировать трек</button>
        <button class="btn btn-primary" onclick="continueTrack()">Продолжить трек</button>
        <button class="btn btn-primary" onclick="generateSingleTrack()">Сгенерировать одну дорожку</button>
        <button class="btn btn-primary" id="loopToggle" onclick="toggleLoop()">Включить повтор</button>
        <div>
            <label for="midiUpload" class="btn btn-primary" id="midiUploadLabel">
                Конвертировать MIDI
                <input type="file" id="midiUpload" accept=".mid,.midi" style="display: none;">
            </label>
        </div>
    </div>
    <div id="player">
        <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
            <audio id="audio" controls></audio>
            <div style="display: flex; flex-direction: column; align-items: center;">
                <label for="volumeSlider">Громкость:</label>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
                <label for="speedSlider" style="margin-top: 10px;">Скорость: <span id="speedValue">1.0</span>x</label>
                <input type="range" id="speedSlider" min="0.5" max="2" step="0.1" value="1">
            </div>
        </div>
        <canvas id="visualizer" width="600" height="200" style="margin-top: 20px;"></canvas>
    </div>
    <div>
        <button id="download" class="btn btn-primary" onclick="downloadTrack()" style="display: none;">Скачать WAV</button>
        <button id="downloadMidi" class="btn btn-primary" onclick="downloadMidi()" style="display: none;">Скачать MID</button>
        <button id="share" class="btn btn-primary" onclick="shareLink()" style="display: none;">Скопировать ссылку</button>
    </div>

    <script src="/static/auth.js"></script>
    <script>
        let currentTrackId = null;
        let audioContext, analyser, source;

        window.onload = function() {
            console.log("Page loaded, initializing...");
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const trackIdFromUrl = urlParams.get('track_id');
                if (trackIdFromUrl) {
                    console.log("Found track_id in URL:", trackIdFromUrl);
                    loadTrack(trackIdFromUrl);
                }

                const midiInput = document.getElementById('midiUpload');
                midiInput.addEventListener('change', uploadMidi);
                console.log("MIDI upload input listener attached");
            } catch (error) {
                console.error("Error during page initialization:", error);
            }
        };

        async function loadTrack(trackId) {
            try {
                const audioUrl = `/static/wavs/${trackId}.wav`;
                currentTrackId = trackId;
                console.log("Loading track from URL with ID:", currentTrackId);
                updatePlayer(audioUrl, trackId);
            } catch (error) {
                console.error("Error loading track:", error);
            }
        }

        async function generateTrack() {
            try {
                console.log("Generating new track...");

                const saveToHistory = localStorage.getItem("saveToHistory") !== "false";

                const user = firebase.auth().currentUser;
                const token = user ? await user.getIdToken() : null;

                const response = await fetch(`/generate_track?saveToHistory=${saveToHistory}`, {
                    method: "GET",
                    headers: token ? { "Authorization": `Bearer ${token}` } : {}
                });

                const data = await response.json();
                if (data.audio_url) {
                    currentTrackId = data.track_id;
                    console.log("Generated new track with ID:", currentTrackId);
                    updatePlayer(data.audio_url, data.track_id);
                } else {
                    console.error("No audio_url in response:", data);
                }
            } catch (error) {
                console.error("Error generating track:", error);
            }
        }


        async function continueTrack() {
            try {
                if (!currentTrackId) {
                    console.log("No current track ID, generating new track instead");
                    await generateTrack();
                    return;
                }
                console.log("Continuing track with ID:", currentTrackId);
                const saveToHistory = localStorage.getItem("saveToHistory") !== "false";
                const user = firebase.auth().currentUser;
                const token = user ? await user.getIdToken() : null;

                const response = await fetch(`/continue_track?track_id=${currentTrackId}&saveToHistory=${saveToHistory}`, {
                    method: "GET",
                    headers: token ? { "Authorization": `Bearer ${token}` } : {}
                });
                const data = await response.json();
                if (data.audio_url) {
                    currentTrackId = data.track_id;
                    console.log("Continued track, new ID:", currentTrackId);
                    updatePlayer(data.audio_url, data.track_id);
                } else {
                    console.error("No audio_url in response:", data);
                }
            } catch (error) {
                console.error("Error continuing track:", error);
            }
        }

        async function generateSingleTrack() {
            try {
                console.log("Generating single track...");
                const saveToHistory = localStorage.getItem("saveToHistory") !== "false";
                const user = firebase.auth().currentUser;
                const token = user ? await user.getIdToken() : null;

                const response = await fetch(`/generate_single_track?saveToHistory=${saveToHistory}`, {
                    method: "GET",
                    headers: token ? { "Authorization": `Bearer ${token}` } : {}
                });
                const data = await response.json();
                if (data.audio_url) {
                    currentTrackId = data.track_id;
                    console.log("Generated single track with ID:", currentTrackId);
                    updatePlayer(data.audio_url, data.track_id);
                } else {
                    console.error("No audio_url in response:", data);
                }
            } catch (error) {
                console.error("Error generating single track:", error);
            }
        }

        async function uploadMidi() {
            try {
                console.log("Starting MIDI upload...");
                const midiInput = document.getElementById('midiUpload');
                const uploadLabel = document.getElementById('midiUploadLabel');
                if (!midiInput.files || midiInput.files.length === 0) {
                    console.log("No MIDI file selected");
                    return;
                }
                const file = midiInput.files[0];
                console.log("Selected MIDI file:", file.name);

                uploadLabel.textContent = "Загрузка...";
                uploadLabel.classList.add('disabled');
                midiInput.disabled = true;

                const formData = new FormData();
                formData.append('midi', file);

                const saveToHistory = localStorage.getItem("saveToHistory") !== "false";
                const user = firebase.auth().currentUser;
                const token = user ? await user.getIdToken() : null;

                const response = await fetch(`/upload_midi?saveToHistory=${saveToHistory}`, {
                    method: 'POST',
                    body: formData,
                    headers: token ? { "Authorization": `Bearer ${token}` } : {}
                });
                const data = await response.json();
                if (data.audio_url) {
                    currentTrackId = data.track_id;
                    console.log("Uploaded and converted MIDI to chiptune, track ID:", currentTrackId);
                    updatePlayer(data.audio_url, data.track_id);
                    midiInput.value = '';
                } else if (data.error) {
                    console.error("Server returned error:", data.error);
                    alert(data.error);
                }
            } catch (error) {
                console.error("Error uploading MIDI:", error);
                alert("Ошибка при загрузке MIDI: " + error.message);
            } finally {
                const uploadLabel = document.getElementById('midiUploadLabel');
                uploadLabel.textContent = "Конвертировать MIDI";
                uploadLabel.classList.remove('disabled');
                midiInput.disabled = false;
            }
        }

        function updatePlayer(audioUrl, trackId) {
            try {
                console.log("Updating player with audio URL:", audioUrl, "and track ID:", trackId);
                const audioElement = document.getElementById('audio');
                const player = document.getElementById('player');
                const downloadButton = document.getElementById('download');
                const downloadMidiButton = document.getElementById('downloadMidi');
                const shareButton = document.getElementById('share');
                const loopToggle = document.getElementById('loopToggle');
                const volumeSlider = document.getElementById('volumeSlider');
                const speedSlider = document.getElementById('speedSlider');
                const speedValue = document.getElementById('speedValue');

                audioElement.src = audioUrl + '?t=' + new Date().getTime();
                audioElement.loop = loopToggle.classList.contains('active');
                audioElement.volume = volumeSlider.value;
                audioElement.playbackRate = speedSlider.value;
                audioElement.load();

                setupAudioContext(audioElement);

                audioElement.onplay = () => {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    startVisualization();
                };

                audioElement.play();
                player.style.display = 'block';
                downloadButton.style.display = 'inline-block';
                downloadMidiButton.style.display = 'inline-block';
                shareButton.style.display = 'inline-block';

                volumeSlider.oninput = function() {
                    audioElement.volume = this.value;
                };

                speedSlider.oninput = function() {
                    audioElement.playbackRate = this.value;
                    speedValue.textContent = parseFloat(this.value).toFixed(1);
                };

                speedValue.textContent = parseFloat(speedSlider.value).toFixed(1);
            } catch (error) {
                console.error("Error updating player:", error);
            }
        }

        function toggleLoop() {
            try {
                console.log("Toggling loop...");
                const loopToggle = document.getElementById('loopToggle');
                const audioElement = document.getElementById('audio');

                loopToggle.classList.toggle('active');
                if (loopToggle.classList.contains('active')) {
                    loopToggle.textContent = 'Выключить повтор';
                    audioElement.loop = true;
                } else {
                    loopToggle.textContent = 'Включить повтор';
                    audioElement.loop = false;
                }
            } catch (error) {
                console.error("Error toggling loop:", error);
            }
        }

        function shareLink() {
            try {
                if (!currentTrackId) {
                    console.log("No track to share");
                    return;
                }
                const shareUrl = `${window.location.origin}/?track_id=${currentTrackId}`;
                navigator.clipboard.writeText(shareUrl);
                console.log("Copied share link:", shareUrl);
            } catch (error) {
                console.error("Error sharing link:", error);
            }
        }

        function downloadTrack() {
            try {
                if (!currentTrackId) {
                    console.log("No track to download");
                    return;
                }
                const volumeSlider = document.getElementById('volumeSlider');
                const volume = volumeSlider.value;
                console.log("Downloading track with ID:", currentTrackId, "and volume:", volume);
                window.location.href = `/download?track_id=${currentTrackId}&volume=${volume}`;
            } catch (error) {
                console.error("Error downloading track:", error);
            }
        }

        function downloadMidi() {
            try {
                if (!currentTrackId) {
                    console.log("No MIDI track to download");
                    return;
                }
                console.log("Downloading MIDI with ID:", currentTrackId);
                window.location.href = `/download_midi?track_id=${currentTrackId}`;
            } catch (error) {
                console.error("Error downloading MIDI:", error);
            }
        }

        function setupAudioContext(audioElement) {
            try {
                console.log("Setting up audio context...");
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                }

                if (source) {
                    source.disconnect();
                }

                source = audioContext.createMediaElementSource(audioElement);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch (error) {
                console.error("Error setting up audio context:", error);
            }
        }

        function startVisualization() {
            try {
                console.log("Starting visualization...");
                const canvas = document.getElementById('visualizer');
                const canvasCtx = canvas.getContext('2d');
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                function draw() {
                    requestAnimationFrame(draw);

                    canvasCtx.fillStyle = '#000000';
                    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

                    analyser.getByteFrequencyData(dataArray);

                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = dataArray[i] * 1.5;
                        canvasCtx.fillStyle = `rgb(${barHeight + 100}, 50, 150)`;
                        canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }
                }

                draw();
            } catch (error) {
                console.error("Error starting visualization:", error);
            }
        }
    </script>
    <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93b98efe2da97bd6',t:'MTc0NjU0NTg0My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>